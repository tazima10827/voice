<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap">
<link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;700&display=swap" rel="stylesheet">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>AmiVoice DSR WebSocket Recognition Protocol Checker</title>
<script type="text/javascript" src="recorder.js"></script>
<script type="text/javascript" src="wrp.js"></script>
<script type="text/javascript" src="result.js"></script>
<style type="text/css">
table {table-layout: fixed; height: 1px;}
td {font-size: 14px; border: 1px solid #000;}
.text {font-size: 14px; font-family: inconsolata, consolas, monospace; width: 100%; height: 21px; margin: 0; padding: 2px; border: none; box-sizing: border-box;}
.checkbox {margin: 2px; vertical-align: middle;}
#messages div {
  padding: 3px 0;
  font-family: monospace;
}
#issueButton {
  height: 32px;
  cursor: pointer;
}
#resumePauseButton {
  height: 100%;
  cursor: pointer;
}
.recognitionResult {
  background-color: #00FF00;
  height: 300px;
  display: flex; /* 子要素の配置を制御するためにFlexboxを使用 */
  flex-direction: column; /* 子要素を縦方向に並べる */
  justify-content: flex-end; /* 子要素を下部に配置 */
  padding-bottom: 30px; /* 必要に応じて下部の余白を調整 */
}

.recognitionResult div {
  text-align: center;
  padding: 0 50px; /* 左右に余白を追加 */
}

.recognitionResultText{
  font-family: 'Zen Maru Gothic', sans-serif; /* フォントを設定 */
  font-size: 26px;
  color: white; /* 文字の色を黒に設定 */
  -webkit-text-stroke-width: 1px; /* 初期の縁取りの太さを設定 */
  -webkit-text-stroke-color: rgb(61, 61, 61);
  font-weight: 600; /* 初期の文字の太さ */
}

.translationResultText {
  font-family: 'Zen Maru Gothic', sans-serif; /* フォントを設定 */
  font-size: 32px;
  color: rgb(47, 9, 236); /* 文字の色を黒に設定 */
  -webkit-text-stroke-width: 0px; /* 初期の縁取りの太さを設定 */
  -webkit-text-stroke-color:rgb(57, 107, 231);
  font-weight: 600; /* 初期の文字の太さ */
}

.recognitionResultInfo {
  font-size: 15px;
  color: lightgrey;
  float: right;
}
.sending {
  color: white;
  background: red;
}
.supplement {
  font-size: 12px;
}
.bar {
  position: relative;
}
.stroke-single-imb {
    left: 0;
    right: 0;
    margin: 0;
    /* -webkit-text-stroke: 0px #0000FF;  */
}

.stroke-single-bg {
    position: absolute;
    left: 0;
    right: 0;
    margin: auto;
    /* -webkit-text-stroke: 3px #FF0000;  */
}

.stroke-single-fg {
    position: absolute;
    left: 0;
    right: 0;
    margin: auto;
    /* -webkit-text-stroke: 0px #FFFFFF; */
}

#version {
  font-size: 10px;
  position: absolute;
  right: 0;
  top: -12px;
}
</style>
</head>
<table border="0" width="100%" cellspacing="3" cellpadding="0">
<tr><td width="270">&nbsp;ワンタイムAppKey発行API URL</td><td><input type="text" class="text" id="issuerURL" spellcheck="false" tabindex="1"></td></tr>
 <tr><td width="270">&nbsp;サーバ URL</td><td><input type="text" class="text" id="serverURL" spellcheck="false" tabindex="3"></td></tr>
 <tr><td>&nbsp;接続エンジン名</td><td><input type="text" class="text grammarFileNames" spellcheck="false" tabindex="3"></td></tr>
 <tr><td>&nbsp;プロファイル ID</td><td><input type="text" class="text" id="profileId" spellcheck="false" tabindex="3"></td></tr>
 <tr class="options" style="display:none;"><td>&nbsp;プロファイル単語</td><td><input type="text" class="text" id="profileWords" spellcheck="false" tabindex="3"></td></tr>
 <tr class="options" style="display:none;"><td>&nbsp;セグメンタプロパティ文字列</td><td><input type="text" class="text" id="segmenterProperties" spellcheck="false" tabindex="3"></td></tr>
 <tr class="options" style="display:none;"><td>&nbsp;フィラー単語を保持するかどうか</td><td><input type="text" class="text" id="keepFillerToken" spellcheck="false" tabindex="3"></td></tr>
 <tr class="options" style="display:none;"><td>&nbsp;認識中イベント発行間隔 (単位：ミリ秒)</td><td><input type="text" class="text" id="resultUpdatedInterval" spellcheck="false" tabindex="3"></td></tr>
 <tr class="options" style="display:none;"><td>&nbsp;拡張情報</td><td><input type="text" class="text" id="extension" spellcheck="false" tabindex="3"></td></tr>
 <tr><td>&nbsp;APPKEY</td><td><input type="password" class="text" id="authorization" spellcheck="false" tabindex="3"></td></tr>
 <tr><td>&nbsp;GoogleAPIKEY</td><td><input type="password" class="text" id="googleapikey" spellcheck="false" tabindex="3"></td></tr>
 <tr class="options" style="display:none;"><td>&nbsp;<font color="silver">音声データ形式</font></td><td><input type="text" class="text" id="codec" spellcheck="false" tabindex="3" readonly></td></tr>
 <tr class="options" style="display:none;"><td>&nbsp;認識結果タイプ</td><td><input type="text" class="text" id="resultType" spellcheck="false" tabindex="3"></td></tr>
 <tr class="options" style="display:none;"><td>&nbsp;無発話許容時間 (単位：ミリ秒)</td><td><input type="text" class="text" id="checkIntervalTime" spellcheck="false" tabindex="3"></td></tr>
 <tr class="options" style="display:none;"><td>&nbsp;録音サンプリング周波数</td><td><input type="text" class="text" id="sampleRate" spellcheck="false" tabindex="3"></td></tr>
 <tr class="options" style="display:none;"><td>&nbsp;連続録音可能時間 (単位: ミリ秒)</td><td><input type="text" class="text" id="maxRecordingTime" spellcheck="false" tabindex="3"></td></tr>
 <tr class="options" style="display:none;"><td>&nbsp;ダウンサンプリング</td><td><input type="checkbox" class="checkbox" id="downSampling" tabindex="3"></td></tr>
 <tr class="options" style="display:none;"><td>&nbsp;ADPCM 圧縮</td><td><input type="checkbox" class="checkbox" id="adpcmPacking" tabindex="3"></td></tr>
</table>
<table border="0" width="100%" cellspacing="3" cellpadding="0">
<tr>
  <td>
    <button class="text" id="resumePauseButton" tabindex="5" style="height: 30px;">録音の開始</button>
  </td>
</tr>
</table>
<table border="0" width="100%" cellspacing="3" cellpadding="0">
  <tr>
     <td class="recognitionResult" style="background-color: #00FF00; height: 300px; display: flex; flex-direction: column; justify-content: flex-end;">
       <div style="text-align: center; padding: 0 20px; margin-bottom: -2.5px;"> <!-- 下の余白を少なく設定 -->
         <span class="recognitionResultText" style="display: none;">認識結果のテキスト</span>
       </div>
       <div style="text-align: center; padding: 0 20px; margin-top: -2.5px;"> <!-- 上の余白を少なく設定 -->
         <span class="translationResultText">翻訳結果のテキスト</span>
       </div>
     </td>
  </tr>
<tr class="recognitionResultInfo"></tr>
</table>

<div style="margin: 20px 2px 24px 2px;">
 <b>[録音の開始]</b> ボタンを押して、マイクに向かって話してください。 <img src="data:image/gif;base64,R0lGODlhCgAPAMIAAAAAABYWFqqqqufn5////wAAAAAAAAAAACH5BAEKAAcALAAAAAAKAA8AAAMmSLq8E2E0AiqY9raMba/MxWmiRw4ZqgACdQka3BLyAltzqDF3NScAOw==" alt="" width="10" height="15"> マイクの使用や共有などを求められた場合は、「許可」 ボタンまたは 「共有」 ボタンを押してください<span class="toggle_options">。</span>
</div>
<div style="margin: 20px 2px 24px 2px;color: red;">
 <b>使い方</b><br>
 利用するには、AmiVoiceのAPIキーとgoogleのGASのURLが必要です。
 APPKEY・プロファイル ID・GoogleAPIKEYの３つを入力してください。
</div>
<!-- スライダー、色選択、フォント選択を追加 -->

<div style="margin: 20px 2px 24px 2px;">
  <button id="toggleRecognitionText" style="padding: 10px 20px;">日本語字幕をONにする</button>
</div>


<div class="control-group">
  <div class="control-group">
  <div class="header" style="margin: 20px 2px 24px 2px;">
      　　　　サイズ　　　　　　　　　　ウェイト　　　　　　　　縁取り<BR>
  </div>
  <div class="slider-container" style="display: flex; align-items: center;">
      <label>認識:</label>
      <input type="range" id="fontSizeSlider1" min="10" max="50" value="26" oninput="updateFontSize(1)">
      <span id="fontSizeValue1" style="margin-right: 20px;">26px</span>

      <input type="range" id="fontWeightSlider1" min="300" max="900" value="600" step="100" oninput="updateFontWeight(1)">
      <span id="fontWeightValue1" style="margin-right: 20px;">600</span>

      <input type="range" id="fontStrokeSlider1" min="0" max="5" value="1" step="0.5" oninput="updateFontStroke(1)">
      <span id="fontStrokeValue1">1px</span>
  </div>
  <label>認識文字の色:</label>
  <input type="color" id="fontColorPicker1" value="#FFFFFF" onchange="updateFontColor(1)">
  <label for="fontStrokeColorPicker1">認識文字の縁の色:</label>
  <input type="color" id="fontStrokeColorPicker1" value="#3D3D3D" onchange="updateFontStrokeColor(1)">
</div>

<div style="margin: 20px 2px 24px 2px;">
  <div class="slider-container" style="display: flex; align-items: center;">
      <label>翻訳:</label>
      <input type="range" id="fontSizeSlider2" min="10" max="50" value="32" oninput="updateFontSize(2)">
      <span id="fontSizeValue2" style="margin-right: 20px;">32px</span>

      <input type="range" id="fontWeightSlider2" min="300" max="900" value="600" step="100" oninput="updateFontWeight(2)">
      <span id="fontWeightValue2" style="margin-right: 20px;">600</span>

      <input type="range" id="fontStrokeSlider2" min="0" max="5" value="0" step="0.5"  oninput="updateFontStroke(2)">
      <span id="fontStrokeValue2">0px</span>
  </div>
  <label>翻訳文字の色:</label>
<input type="color" id="fontColorPicker2" value="#2f09ec" onchange="updateFontColor(2)">
<label for="fontStrokeColorPicker2">認識文字の縁の色:</label>
<input type="color" id="fontStrokeColorPicker2" value="#396BE7" onchange="updateFontStrokeColor(2)">
</div>

<div style="margin: 20px 2px 24px 2px;">
  <label for="fontSelector">フォントの指定:</label>
  <select id="fontSelector" onchange="updateFontFamily()">
    <option value="Zen Maru Gothic">Zen Maru Gothic</option>
    <option value="'M PLUS Rounded 1c', sans-serif">M PLUS Rounded 1c</option>
    <option value="Arial">Arial</option>
    <option value="Verdana">Verdana</option>
    <option value="Times New Roman">Times New Roman</option>
    <option value="Courier New">Courier New</option>
    <option value="Georgia">Georgia</option>
  </select>
</div>

<script type="text/javascript">

document.getElementById('toggleRecognitionText').addEventListener('click', function() {
    const recognitionText = document.querySelector('.recognitionResultText');
    const button = document.getElementById('toggleRecognitionText');
    if (recognitionText.style.display === 'none') {
        recognitionText.style.display = 'block';
        button.textContent = '日本語字幕をOFFにする'; // ボタンテキストをOFFに変更
    } else {
        recognitionText.style.display = 'none';
        button.textContent = '日本語字幕をONにする'; // ボタンテキストをONに変更
    }
});

function updateFontSize(target) {
  const slider1 = document.getElementById('fontSizeSlider1');
  const sizeValue1 = document.getElementById('fontSizeValue1');
  const slider2 = document.getElementById('fontSizeSlider2');
  const sizeValue2 = document.getElementById('fontSizeValue2');
  const recognitionText = document.querySelector('.recognitionResultText');
  const translationText = document.querySelector('.translationResultText');

  if (target === 1) {
    sizeValue1.innerText = slider1.value + 'px';
    recognitionText.style.fontSize = slider1.value + 'px';
  } else if (target === 2) {
    sizeValue2.innerText = slider2.value + 'px';
    translationText.style.fontSize = slider2.value + 'px';
  }
}

  function updateFontColor(target) {
    const colorPicker1 = document.getElementById('fontColorPicker1');
    const colorPicker2 = document.getElementById('fontColorPicker2');
    const recognitionText = document.querySelector('.recognitionResultText');
    const translationText = document.querySelector('.translationResultText');

    if (target === 1) {
      recognitionText.style.color = colorPicker1.value;
    } else if (target === 2) {
      translationText.style.color = colorPicker2.value;
    }
  }

  function updateFontSize(target) {
  const slider1 = document.getElementById('fontSizeSlider1');
  const sizeValue1 = document.getElementById('fontSizeValue1');
  const slider2 = document.getElementById('fontSizeSlider2');
  const sizeValue2 = document.getElementById('fontSizeValue2');
  const recognitionText = document.querySelector('.recognitionResultText');
  const translationText = document.querySelector('.translationResultText');

  if (target === 1) {
    sizeValue1.innerText = slider1.value + 'px';
    recognitionText.style.fontSize = slider1.value + 'px';
  } else if (target === 2) {
    sizeValue2.innerText = slider2.value + 'px';
    translationText.style.fontSize = slider2.value + 'px';
  }
}

//追加ウェイト

function updateFontWeight(target) {
  const slider1 = document.getElementById('fontWeightSlider1');
  const valueDisplay1 = document.getElementById('fontWeightValue1');
  const slider2 = document.getElementById('fontWeightSlider2');
  const valueDisplay2 = document.getElementById('fontWeightValue2');
  const recognitionText = document.querySelector('.recognitionResultText');
  const translationText = document.querySelector('.translationResultText');

  if (target === 1) {
    valueDisplay1.innerText = slider1.value;
    recognitionText.style.fontWeight = slider1.value;
  } else if (target === 2) {
    valueDisplay2.innerText = slider2.value;
    translationText.style.fontWeight = slider2.value;
  }
}

//追加枠

function setTextBorder(width, id) {
    const recognitionText = document.querySelector('.recognitionResultText');
    if (id === 1) {
        recognitionText.style.webkitTextStrokeWidth = width + 'px';
    }
}

function updateFontStroke(target) {
  const slider1 = document.getElementById('fontStrokeSlider1');
  const strokeValue1 = document.getElementById('fontStrokeValue1');
  const slider2 = document.getElementById('fontStrokeSlider2');
  const strokeValue2 = document.getElementById('fontStrokeValue2');
  const recognitionText = document.querySelector('.recognitionResultText');
  const translationText = document.querySelector('.translationResultText');

  if (target === 1) {
    strokeValue1.innerText = slider1.value + 'px';
    recognitionText.style.webkitTextStrokeWidth = slider1.value + 'px';
  } else if (target === 2) {
    strokeValue2.innerText = slider2.value + 'px';
    translationText.style.webkitTextStrokeWidth = slider2.value + 'px';
  }
}

function updateFontStrokeColor(target) {
  const colorPicker1 = document.getElementById('fontStrokeColorPicker1');
  const colorPicker2 = document.getElementById('fontStrokeColorPicker2');
  const recognitionText = document.querySelector('.recognitionResultText');
  const translationText = document.querySelector('.translationResultText');

  if (target === 1) {
    recognitionText.style.webkitTextStrokeColor = colorPicker1.value;
  } else if (target === 2) {
    translationText.style.webkitTextStrokeColor = colorPicker2.value;
  }
}
//追加縁枠変更
function updateTextStroke() {
        const slider = document.getElementById('textStrokeSlider');
        const value = slider.value;
        const valueDisplay = document.getElementById('textStrokeValue');
        const recognitionText = document.querySelector('.recognitionResultText');

        valueDisplay.textContent = value + 'px';
        recognitionText.style.webkitTextStrokeWidth = value + 'px'; // 縁取りの太さを更新
}

function updateFontFamily() {
  const fontSelector = document.getElementById('fontSelector');
  const recognitionText = document.querySelector('.recognitionResultText');
  const translationText = document.querySelector('.translationResultText');

  recognitionText.style.fontFamily = fontSelector.value;
  translationText.style.fontFamily = fontSelector.value;
}

  function updateFontFamily() {
    const fontSelector = document.getElementById('fontSelector');
    const recognitionText = document.querySelector('.recognitionResultText');
    const translationText = document.querySelector('.translationResultText');

    recognitionText.style.fontFamily = fontSelector.value;
    translationText.style.fontFamily = fontSelector.value;
  }
</script>

<div class="bar"><hr><div id="version"></div></div>
<div id="messages"></div>
<script type="text/javascript">
(function() {
  // <!--
  function log_(n, s) {
    console.log(n + s);
    var color = "";
    if (s.lastIndexOf("EVENT: ", 0) != -1) {
//    color = "green";
    } else
    if (s.lastIndexOf("INFO: ", 0) != -1) {
//    color = "blue";
    } else
    if (s.lastIndexOf("ERROR: ", 0) != -1) {
      color = "red";
    } else {
      color = "black";
    }
    if (color) {
      if (messages.childNodes.length >= 20) {
        messages.removeChild(messages.lastChild);
      }
      messages.insertBefore(document.createElement("div"), messages.firstChild).innerHTML = n + s;
      messages.firstChild.style.borderBottom = "1px #ddd solid";
      messages.firstChild.style.color = color;
    }
  }
  function sanitize_(s) {
    return s.replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/'/g, '&apos;')
            .replace(/"/g, '&quot;');
  }
  // -->
  // 音声認識サーバへの接続処理が開始した時に呼び出されます。
  function connectStarted() {
    // log_(this.name, "EVENT: connectStarted()");
  }

  // 音声認識サーバへの接続処理が完了した時に呼び出されます。
  function connectEnded() {
    // log_(this.name, "EVENT: connectEnded()");
  }

  // 音声認識サーバからの切断処理が開始した時に呼び出されます。
  function disconnectStarted() {
    // log_(this.name, "EVENT: disconnectStarted()");
  }

  // 音声認識サーバからの切断処理が完了した時に呼び出されます。
  function disconnectEnded() {
    // log_(this.name, "EVENT: disconnectEnded()");
    // ボタンの制御
    resumePauseButton.innerHTML = "録音の開始";
    resumePauseButton.disabled = false;
    resumePauseButton.classList.remove("sending");
  }

  // 音声認識サーバへの音声データの供給開始処理が開始した時に呼び出されます。
  function feedDataResumeStarted() {
    // this.recognitionResultText.innerHTML = "音声入力を開始します";
    // this.translationResultText.innerHTML = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    this.recognitionResultText.innerHTML = "";
    this.translationResultText.innerHTML = "";

    // log_(this.name, "EVENT: feedDataResumeStarted()");
  }

  // 音声認識サーバへの音声データの供給開始処理が完了した時に呼び出されます。
  function feedDataResumeEnded() {
    // log_(this.name, "EVENT: feedDataResumeEnded()");
    // ボタンの制御
    resumePauseButton.innerHTML = "音声データの録音中...<span class=\"supplement\">クリック → 録音の停止</span>";
    resumePauseButton.disabled = false;
    resumePauseButton.classList.add("sending");

    document.querySelector('.recognitionResultText').style.display = 'block';
    document.querySelector('.translationResultText').style.display = 'block';
  }

  // 音声認識サーバへの音声データの供給終了処理が開始した時に呼び出されます。
  function feedDataPauseStarted() {
    // log_(this.name, "EVENT: feedDataPauseStarted()");
  }

  // 音声認識サーバへの音声データの供給終了処理が完了した時に呼び出されます。
  function feedDataPauseEnded(reason) {
    // log_(this.name, "EVENT: feedDataPauseEnded(): reason[code[" + reason.code + "] message[" + reason.message + "]]");
    document.querySelector('.recognitionResultText').style.display = 'none';
    document.querySelector('.translationResultText').style.display = 'none';
  }

  // 発話区間の始端が検出された時に呼び出されます。
  function utteranceStarted(startTime) {
    // log_(this.name, "EVENT: utteranceStarted(): endTime[" + startTime + "]");
  }

  // 発話区間の終端が検出された時に呼び出されます。
  function utteranceEnded(endTime) {
    // log_(this.name, "EVENT: utteranceEnded(): endTime[" + endTime + "]");
  }

  // 認識処理が開始された時に呼び出されます。
  function resultCreated() {
    // log_(this.name, "EVENT: resultCreated()");
    this.recognitionResultText.innerHTML = "...";
    this.recognitionResultInfo.innerHTML = "";
    this.startTime = new Date().getTime();
  }

  // 認識処理中に呼び出されます。
  function resultUpdated(result) {
    // log_(this.name, "EVENT: resultUpdated(): result[" + result + "]");
    result = Result.parse(result);
    var text = (result.text) ? sanitize_(result.text) : "...";
    this.recognitionResultText.innerHTML = text;
  }

  // 認識処理が確定した時に呼び出されます。
  function resultFinalized(result) {
    // log_(this.name, "EVENT: resultFinalized(): result[" + result + "]");
    result = Result.parse(result);
    var text = (result.text) ? sanitize_(result.text) : (result.code != 'o' && result.message) ? "<font color=\"gray\">(" + result.message + ")</font>" : "<font color=\"gray\">()</font>";
    var duration = result.duration;
    var elapsedTime = new Date().getTime() - this.startTime;
    var confidence = result.confidence;
    var rt = ((duration > 0) ? (elapsedTime / duration).toFixed(2) : "-") + " (" + (elapsedTime / 1000).toFixed(2) + "/" + ((duration > 0) ? (duration / 1000).toFixed(2) : "-") + ")";
    var cf = (confidence >= 0.0) ? confidence.toFixed(2) : "-";
    this.recognitionResultText.innerHTML = text;
    this.recognitionResultInfo.innerHTML = "";
    log_(this.name, text + " <font color=\"darkgray\">(RT: " + rt + ") (CF: " + cf + ")</font>");
    //ここで翻訳処理を行い、logで表示する処理を記述する。
    // const text = document.getElementById('text').value;
    // const source = document.getElementById('source').value;
    // const target = document.getElementById('target').value;
    const googleApiKeyElement = document.getElementById('googleapikey');
    const googleApiKey = googleApiKeyElement.value;
    console.log("Google API Key: ", googleApiKey);
    const url = googleApiKey +
                `?text=${encodeURIComponent(text)}&source=${encodeURIComponent('ja')}&target=${encodeURIComponent('en')}`;
    fetch(url)
      .then(response => response.json())
      .then(data => {
        if (data.error) {
          log_(this.name, 'エラー: ' + data.error);
        } else {
          this.translationResultText.innerHTML = `${data.translatedText}`;
          log_(this.name, `翻訳結果: ${data.translatedText}\n翻訳回数: ${data.translatedCount}`);
        }
      })
      .catch(error => {
        console.error('Error:', error);
        log_(this.name, '翻訳にエラーが発生しました。GoogleAPIKEYを確認してください。');
      });

  }

  // 各種イベントが通知された時に呼び出されます。
  function eventNotified(eventId, eventMessage) {
    // log_(this.name, "EVENT: eventNotified(): eventId[" + eventId + "] eventMessage[" + eventMessage + "]");
  }

  // メッセージの出力が要求された時に呼び出されます。
  function TRACE(message) {
    // log_(this.name || "", message);
  }

  // 画面要素の取得
  var issuerURL = document.getElementById("issuerURL");
  var sid = document.getElementById("sid");
  var spw = document.getElementById("spw");
  var epi = document.getElementById("epi");
  var issueButton = document.getElementById("issueButton");
  var grammarFileNames = document.getElementsByClassName("grammarFileNames");
  var recognitionResultText = document.getElementsByClassName("recognitionResultText");
  var translationResultText = document.getElementsByClassName("translationResultText");
  var recognitionResultInfo = document.getElementsByClassName("recognitionResultInfo");

  // 音声認識ライブラリのプロパティ要素の設定
  Wrp.serverURLElement = serverURL;
  Wrp.grammarFileNamesElement = grammarFileNames[0];
  Wrp.profileIdElement = profileId;
  Wrp.profileWordsElement = profileWords;
  Wrp.segmenterPropertiesElement = segmenterProperties;
  Wrp.keepFillerTokenElement = keepFillerToken;
  Wrp.resultUpdatedIntervalElement = resultUpdatedInterval;
  Wrp.extensionElement = extension;
  Wrp.authorizationElement = authorization;
  Wrp.codecElement = codec;
  Wrp.resultTypeElement = resultType;
  Wrp.checkIntervalTimeElement = checkIntervalTime;
  Wrp.issuerURLElement = issuerURL;
  Wrp.sidElement = sid;
  Wrp.spwElement = spw;
  Wrp.epiElement = epi;
  Wrp.name = "";
  Wrp.recognitionResultText = recognitionResultText[0];
  Wrp.translationResultText = translationResultText[0];
  Wrp.recognitionResultInfo = recognitionResultInfo[0];

  // 音声認識ライブラリのイベントハンドラの設定
  Wrp.connectStarted = connectStarted;
  Wrp.connectEnded = connectEnded;
  Wrp.disconnectStarted = disconnectStarted;
  Wrp.disconnectEnded = disconnectEnded;
  Wrp.feedDataResumeStarted = feedDataResumeStarted;
  Wrp.feedDataResumeEnded = feedDataResumeEnded;
  Wrp.feedDataPauseStarted = feedDataPauseStarted;
  Wrp.feedDataPauseEnded = feedDataPauseEnded;
  Wrp.utteranceStarted = utteranceStarted;
  Wrp.utteranceEnded = utteranceEnded;
  Wrp.resultCreated = resultCreated;
  Wrp.resultUpdated = resultUpdated;
  Wrp.resultFinalized = resultFinalized;
  Wrp.eventNotified = eventNotified;
  Wrp.TRACE = TRACE;

  // 録音ライブラリのプロパティ要素の設定
  Recorder.sampleRateElement = sampleRate;
  Recorder.maxRecordingTimeElement = maxRecordingTime;
  Recorder.downSamplingElement = downSampling;
  Recorder.adpcmPackingElement = adpcmPacking;

  // 画面要素の初期化
  issuerURL.value = "https://acp-api.amivoice.com/issue_service_authorization";
  serverURL.value = "wss://acp-api.amivoice.com/v1/";
  grammarFileNames[0].value = Wrp.grammarFileNames;
  profileId.value = Wrp.profileId;
  profileWords.value = Wrp.profileWords;
  segmenterProperties.value = Wrp.segmenterProperties;
  keepFillerToken.value = Wrp.keepFillerToken;
  resultUpdatedInterval.value = Wrp.resultUpdatedInterval;
  extension.value = Wrp.extension;
  authorization.value = Wrp.authorization;
  codec.value = Wrp.codec;
  resultType.value = Wrp.resultType;
  checkIntervalTime.value = Wrp.checkIntervalTime;
  sampleRate.value = Recorder.sampleRate;
  maxRecordingTime.value = Recorder.maxRecordingTime;
  downSampling.checked = Recorder.downSampling;
  adpcmPacking.checked = Recorder.adpcmPacking;

  // 音声認識ライブラリ／録音ライブラリのメソッドの画面要素への登録
  resumePauseButton.onclick = function() {
    // 音声認識サーバへの音声データの供給中かどうかのチェック
    if (Wrp.isActive()) {
      // 音声認識サーバへの音声データの供給中の場合...
      // 音声認識サーバへの音声データの供給の停止
      Wrp.feedDataPause();

      // ボタンの制御
      resumePauseButton.disabled = true;
    } else {
      // 音声認識サーバへの音声データの供給中でない場合...
      // グラマファイル名が指定されているかどうかのチェック
      if (Wrp.grammarFileNamesElement.value != "") {
        // グラマファイル名が指定されている場合...
        // 音声認識サーバへの音声データの供給の開始
        Wrp.feedDataResume();

        // ボタンの制御
        resumePauseButton.disabled = true;
      } else {
        // グラマファイル名が指定されていない場合...
        // (何もしない)
      }
    }
  };
  issueButton.onclick = Wrp.issue;

  var issue_options = document.querySelectorAll(".issue_options");
  function toggle_issue_options() {
    issue_options[0].style.display = (issue_options[0].style.display === "") ? "" : "";
    for (var i = 1; i < issue_options.length; i++) {
      issue_options[i].style.display = issue_options[0].style.display;
    }
  }
  var toggle_issue_optionss = document.querySelectorAll(".toggle_issue_options");
  for (var i = 0; i < toggle_issue_optionss.length; i++) {
    toggle_issue_optionss[i].onclick = toggle_issue_options;
    toggle_issue_optionss[i].style.cursor = "pointer";
  }

  var options = document.querySelectorAll(".options");
  function toggle_options() {
    options[0].style.display = (options[0].style.display === "") ? "" : "";
    for (var i = 1; i < options.length; i++) {
      options[i].style.display = options[0].style.display;
    }
  }
  var toggle_optionss = document.querySelectorAll(".toggle_options");
  for (var i = 0; i < toggle_optionss.length; i++) {
    toggle_optionss[i].onclick = toggle_options;
    toggle_optionss[i].style.cursor = "pointer";
  }

  version.innerHTML = Wrp.version + " " + Result.version;
})();
</script>
</body>
</html>
